## TCP 首部
![TCP 首部](https://i.screenshot.net/lolvkhv)

![TCP-Header-01](https://i.screenshot.net/mxe35a4)
![TCP-Header-01](https://i.screenshot.net/m56l2f8)

#### 源端口号 Source Port 和目的端口号 Destination Port
用于寻找发端和收端应用进程。这两个值加上 IP 首部中的源端 IP 地址和目的端 IP 地址唯一确定一个 TCP 连接。

#### 序号字段 Sequence Number
序号用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。

如果将字节流看作在两个应用程序间的单向流动，则  TCP 用序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2^32 - 1 后又从0开始。

当建立一个新的连接时，SYN 标志变1。序号字段包含由这个主机选择的该连接的初始序号 [ISN（Initial Sequence Number）](https://blog.csdn.net/zhangqi_gsts/article/details/50617291)。初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。

#### 确认序号 Acknowledgment Number
既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有 ACK 标志为 1 时确认序号字段才有效。

发送ACK无需任何代价，因为 32bit 的确认序号字段和 ACK 标志一样，总是 TCP 首部的一
部分。因此，一旦一个连接建立起来，这个字段总是被设置， ACK 标志也总是被设置为1。

TCP 为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。

#### 首都长度 Offset
首部长度给出首部中 32bit 字的数目。需要这个值是因为选项字段的长度是可变的。这个字段占 4bit，首部长度计算公式为 2^4 * 4byte。 因此 TCP 最多有 60byte 的首部。然而，没有选项字段，正常的长度是 20byte。

#### 标志字段 TCP Flags
在 TCP 首部中有 6 个标志比特。它们中的多个可同时被设置为1.
- URG 紧急指针有效。
- ACK 确认序号有效。
- PSH 接收方应该尽快将这个报文段交给应用层。
- RST 重建连接。
- SYN 同步序号用来发起一个连接。
- FIN 发端完成发送任务。

#### 窗口大小 Window
TCP 的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。

#### 检验和 Checksum
检验和覆盖了整个的 TCP 报文段：TCP 首部和 TCP 数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

#### 紧急指针 Urgent Pointer
只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。

#### 选项 TCP Options
最常见的可选字段是最大报文段长度，又称为 [MSS (Maximum Segment Size)](https://baike.baidu.com/item/MSS/3567802)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

## TCP 连接建立与终止
<!-- ![TCP 连接和终止](https://i.screenshot.net/l8756i6) -->
 <img src="https://i.screenshot.net/l8756i6" width = "500" alt="TCP 连接和终止" align=center />
 
 ![TCP 连接和终止](https://i.screenshot.net/9mxvecp)
 ![TCP 状态机](https://i.screenshot.net/9on26i9)

### TIME_WAIT 状态
TIME_WAIT 状态也称为 2MSL 等待状态。每个具体TCP实现必须选择一个报文段最大生存时间 MSL (Maximum Segment Lifetime)。MSL 是任何报文段被丢弃前在网络内的最长时间，超过这个时间报文将被丢弃。
> RFC 793 [Postel 1981c] 指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟， 或2分钟。

2MSL 即两倍的 MSL，当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，即第 3 次握 手完成后发送了第四次握手的 ACK 包后就进入了 TIME_WAIT 状态，必须在此状态上停留两倍的 MSL 时间

在 TIME_WAIT 状态下两端的端口不能使用，要等到 2MSL 时间结束才可继续使用。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被丢弃。于是，这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口 (客户的 IP 地址和端口号，服务器的 IP 地址和端口号)不能再被使用，而只能在 2MSL 结束后才能再被使用。

#### 等待 2MSL 的目的 （或者说 TIME_WAIT 状态的作用）
1. 四次挥手的最后一个 ACK 包对方没收到，那么对方在超时后，将重发第三次握手的 FIN 包，主动关闭端接到重发的 FIN 包后可以再发一个 ACK 应答包。如果主动关闭方不进入 TIME_WAIT 以维护其连接状态，则当被动关闭方重发的 FIN 达到时，主动关闭方的 TCP 传输层会以 RST 包响应对方，这会被对方认为有错误发生。
2. 让旧的数据包在网络因过期而消失。防止由旧有的连接的迟到报文段被新连接收到，而引起数据错乱


### 半关闭连接
TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，即是半关闭。

### 复位报文段

一般说来，无论何时一个报文段发往基准的连接（referenced connection）出现错误，TCP都会发出一个复位报文段（这里提到的“基准的连接”是指由目的IP地址和目的端口号以及源IP地址和源端口号指明的连接。）

#### 1. 访问不存在的端口

一个数据报到达目的端口时，该端口没被监听使用，TCP 会发送复位报文

#### 2. 处理半打开连接

如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的 TCP 连接称为半打开（Half-Open）的 。

服务端（或客户端）关闭或者异常终止了连接，而对方没有收到结束报文段（可能发生网络故障），此时客户端（或服务器）还维持原来的连接。如果客户端（或服务器）往处于半打开状态的连接写数据，则对方也会回复一个复位报文段。

#### 3. 异常终止连接

TCP协议提供了异常终止一个连接的方法，即给对方发送一个复位报文段，一旦发送了该报文，发送端所有排队等待发送的数据都将被丢弃，接收端将关闭或者重新建立连接。

### 同时打开

两个应用程序同时彼此执行主动打开的情况是可能的。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口。另外，这种情况下需要进行 4 次握手。
![TCP 两端同时打开](https://i.screenshot.net/2zxogcj)

### 同时关闭
![TCP 两端同时关闭](https://i.screenshot.net/21yp8f3)


## [TCP 各种定时器](http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/)

#### 1. 连接建立定时器 Connection-Establishment Timer

在TCP三次握手创建一个连接时，以下两种情况会发生超时：
- client发送SYN后，进入SYN_SENT状态，等待server的SYN+ACK。
- server收到连接创建的SYN，回应SYN+ACK后，进入SYN_RECD状态，等待client的ACK。
    
当超时发生时，就会重传，一直到75s还没有收到任何回应，便会放弃，终止连接的创建。但是在Linux实现中，并不是依靠超时总时间来判断是否终止连接，而是依赖重传次数。

#### 2. 重连定时器 Retransmission Timer

当三次握手成功，连接建立，发送 TCP segment，等待 ACK 确认。如果在指定时间内，没有得到 ACK，就会重传，一直重传到放弃为止。

#### 3. 延迟确认定时器  Delayed ACK Timer

当一方接受到 TCP segment，需要回应 ACK。但是不需要立即发送，而是等上一段时间，看看是否有其他数据可以捎带一起发送。

TCP 使用了一个 200ms 的定时器，该定时器以相对于内核引导的 200ms 固定时间溢出。由于将要确认的数据是随机到达的，TCP 在内核的 200ms 定时器的下一次溢出时得到通知。这有可能是将来1~200 ms中的任何一刻。
> HostRequirements RFC 声明 TCP 需要实现一个经受时延的 ACK，但时延必须小于 500ms。

#### 4. 持续定时器 Persist Timer

如果某一时刻，一方发现自己的 socket read buffer 满了，无法接收更多的 TCP data，于是在接下来的发送包中指定通告窗口的大小为 0，这样对方就不能接着发送 TCP data 了。如果 socket read buffer 有了空间，可以重设通告窗口的大小在接下来的 TCP segment 中告知对方。可是万一这个 TCP segment 不附带任何 data，所以即使这个 segment 丢失也不会知晓。对方没有接受到，便不知通告窗口的大小发生了变化，也不会发送 TCP data。这样双方便会一直僵持下去。

TCP协议采用这个机制避免这种问题：对方即使知道当前不能发送TCP data，当有data发送时，过一段时间后，也应该尝试发送一个字节。这段时间便是 Persist Timer 。

#### 5. Keepalive Timer 

TCP socket 的 SO_KEEPALIVE option，主要适用于这种场景：连接的双方一般情况下没有数据要发送，仅仅就想尝试确认对方是否依然在线。

具体实现方法：TCP每隔一段时间（tcp_keepalive_intvl）会发送一个特殊的 Probe Segment，强制对方回应，如果没有在指定的时间内回应，便会重传，一直到重传次数达到 tcp_keepalive_probes 便认为对方已经crash了。

#### 6. FIN_WAIT_2 Timer

当主动关闭方想关闭 TCP connection，发送 FIN 并且得到相应 ACK，从 FIN_WAIT_1 状态进入 FIN_WAIT_2 状态，此时不能发送任何 data 了，只等待对方发送 FIN。可以万一对方一直不发送 FIN 呢？这样连接就一直处于 FIN_WAIT_2 状态，也是很经典的一个 DoS。因此需要一个 Timer，超过这个时间，就放弃这个 TCP connection 了。

#### 7. TIME_WAIT Timer
前文已述，略


## 问题
#### TCP 如何实现可靠性传输？
- 应用数据被分割成 TCP 认为最适合发送的数据块
- 当TCP 发出一个段后 ，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。
- TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， TCP 将丢弃这个报文段和不确认收到此报文段(希望发端超时并重发)。
- TCP 报文段的到达可能会失序。如果必要， TCP 将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
- TCP 接收端会丢弃重复的数据。
- 提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。


#### 为什么我们已经讨论的所有 Internet 协议（IP, ICMP, IGMP, UDP, TCP）收到有检验和错的分组都仅作丢弃处理？

当分组的校验和与接收方的计算结果不一致的时候，有三种处理方案：一是立即通知发送方重传；二是直接丢弃分组，等待发送方定时器超时后重传；三是尝试纠错，比如数据链路层中的CRC。

因为接收方是无法判断是哪里出错，尤其是如果分组中出错的字段就是发送方的地址（比如IP分组中源地址字段错了），那么根本无法将重传请求回馈给发送方。所以处理方法就是直接丢弃分组等待超时重传。


#### 如何防止和解决 TIME_WAIT 数量太多

#### TCP 断开连接，为什么是4次挥手，可以不可以3次？
因为发送客户FIN的ACK通常是收到FIN就立刻发送，但这是服务器不一定要关闭自己这端的连接，还可能需要发送数据（半关闭），所以不一定要发送FIN。







---
参考自
- 《TCP-IP 详解》 TCP 相关章节
- [TCP 的那些事儿](https://coolshell.cn/articles/11564.html)
- [TCP协议的那些超时](http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/)